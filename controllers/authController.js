const { promisify } = require('util');
const jwt = require('jsonwebtoken');
const User = require('./../models/userModel');
const catchAsync = require('./../utils/catchAsync');
const AppError = require('./../utils/appError');

const signToken = id => {
  return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRE_LIMIT });
}

exports.signup = catchAsync(async (req, res, next) => {
  // const newUser = await User.create(req.body);
  //changing the above code so that if we are having roles as admin or normal user so that every user cannot become admin by sending the data into the request body so we are going to take only data that we need
  const newUser = await User.create({
    name: req.body.name,
    email: req.body.email,
    password: req.body.password,
    passwordConfirm: req.body.passwordConfirm,
    passwordChangedAt: req.body.passwordChangedAt
  });

  const token = signToken(newUser._id);

  res.status(201).json({
    success: {
      token,
      data: newUser,
      message: 'New User Created'
    }
  });
});

exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  if(!email || !password) return next(new AppError('User email and password is required', 400));
  
  const user = await User.findOne({ email }).select('+password'); // because password is set to be selected as false from the database hence needed to selected specifically
  
  if(!user || !(await user.comparePassword(password, user.password))) {
    return next(new AppError('Invalid email or password', 401));
  }

  const token = signToken(user._id);

  res.status(200).json({
    success: {
      token,
      data: {},
      message: 'Logged in successfully'
    }
  });
});

exports.protect = catchAsync(async (req, res, next) => {
  //1. Generate the token
  let token = null;
  if(req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if(!token) return next(new AppError('You are not authorized', 401));

  //2. Verify the Token
  const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

  //3. Check if the token generated by the user, that user still exists meaning either he has removed his account or not
  const currentUser = await User.findById(decoded.id);
  if(!currentUser) return next(new AppError('User does not exist, PLease check your id or password'), 401);

  //4. Check if the user has recently changed the password after generating the token
  if(currentUser.checkPasswordChangedAfter(decoded.iat)) return next(new AppError('Your password has been changed recently, kindly log in again.'));

  //Making user part of the request itself inorder to grant access to the protected site
  req.user = currentUser;
 
  next();

});

exports.checkAuthority = catchAsync((req, res, next) => {
  const AUTHORITY_ROLES = ['admin', 'lead-guide'];

  if(!AUTHORITY_ROLES.includes(req.user.role)) return next(new AppError('You are not authorized to do this!', 403));
  
  next();
});